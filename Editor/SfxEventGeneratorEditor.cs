using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using RPGFramework.Audio.Sfx;
using UnityEditor;
using UnityEngine;

namespace RPGFramework.Audio.Editor
{
    public class SfxEventGeneratorEditor
    {
        private AudioAssetProviderModalWindow m_Window;
        private SerializedObject              m_SerializedObject;

        internal void OpenModal(SerializedObject serializedObject)
        {
            m_SerializedObject = serializedObject;

            m_Window           =  ScriptableObject.CreateInstance<AudioAssetProviderModalWindow>();
            m_Window.OnConfirm += OnGenerate;

            m_Window.Init("SfxEvents", "Generate Sfx Events class", "SfxEvents.cs");
        }

        private void OnGenerate(string path, string filename, string namespaceForFile)
        {
            m_Window.OnConfirm -= OnGenerate;
            m_Window           =  null;

            OrderedDictionary sfxEvents = new OrderedDictionary();

            SerializedProperty listOfSfxAssets = m_SerializedObject.FindProperty("m_SfxAssets");

            for (int i = 0; i < listOfSfxAssets.arraySize; i++)
            {
                SerializedProperty sfxAssetSerializedProperty = listOfSfxAssets.GetArrayElementAtIndex(i);
                SfxAsset           sfxAsset                   = (SfxAsset)sfxAssetSerializedProperty.objectReferenceValue;

                SerializedObject   sfxAssetSerializedObject = new SerializedObject(sfxAsset);
                SerializedProperty events                   = sfxAssetSerializedObject.FindProperty("m_Events");

                for (int j = 0; j < events.arraySize; j++)
                {
                    SerializedProperty sfxEventProperty = events.GetArrayElementAtIndex(j);
                    ISfxEventData      sfxEventData     = (ISfxEventData)sfxEventProperty.boxedValue;
                    string             eventName        = sfxEventData.EventName;
                    string             key              = ToUpperSnakeCase(eventName);

                    if (!sfxEvents.Contains(key))
                    {
                        sfxEvents.Add(key, eventName);
                    }
                }
            }

            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }

            string filePath = Path.Combine(path, filename);

            if (File.Exists(filePath))
            {
                File.Delete(filePath);
            }

            StringBuilder sb        = new StringBuilder();
            string        className = filename.Split('.')[0];

            GenerateStartOfFile(sb, namespaceForFile);
            GenerateEnumContents(sb, className, sfxEvents);
            GenerateClassContents(sb, className, sfxEvents);
            GenerateEndOfFile(sb);

            File.WriteAllText(filePath, sb.ToString());

            AssetDatabase.Refresh();
        }

        private static void GenerateStartOfFile(StringBuilder sb, string namespaceForFile)
        {
            sb.AppendLine("// THIS FILE IS AUTOGENERATED, DO NOT MODIFY");
            sb.AppendLine($"// Last generated at {DateTime.UtcNow}\n");
            
            sb.AppendLine("using System;");
            sb.AppendLine();

            sb.AppendLine($"namespace {namespaceForFile}");
            sb.AppendLine("{");
        }

        private static void GenerateEnumContents(StringBuilder sb, string className, OrderedDictionary sfxEvents)
        {
            sb.AppendLine($"\tpublic enum {className}Enum");
            sb.AppendLine("\t{");

            int i = 0;
            foreach (DictionaryEntry dictionaryEntry in sfxEvents)
            {
                sb.AppendLine($"\t\t{dictionaryEntry.Key} = {i},");
                i++;
            }

            sb.AppendLine("\t}");
            sb.AppendLine();
        }

        private static void GenerateClassContents(StringBuilder sb, string className, OrderedDictionary sfxEvents)
        {
            sb.AppendLine($"\tpublic static class {className}");
            sb.AppendLine("\t{");

            foreach (DictionaryEntry dictionaryEntry in sfxEvents)
            {
                sb.AppendLine($"\t\tpublic const string {dictionaryEntry.Key} = \"{dictionaryEntry.Value}\";");
            }

            sb.AppendLine();
            sb.AppendLine($"\t\tpublic static string GetByEnum({className}Enum value)");
            sb.AppendLine("\t\t{");

            sb.AppendLine("\t\t\treturn value switch");
            sb.AppendLine("\t\t\t{");

            foreach (DictionaryEntry dictionaryEntry in sfxEvents)
            {
                sb.AppendLine($"\t\t\t\t{className}Enum.{dictionaryEntry.Key} => {dictionaryEntry.Key},");
            }
            
            sb.AppendLine($"\t\t\t\t_ => throw new ArgumentOutOfRangeException(nameof(value), value, null)");
            
            sb.AppendLine("\t\t\t};");

            sb.AppendLine("\t\t}");

            sb.AppendLine("\t}");
            
            //TODO: create static classes for each SfxAsset so we can do Sfx_00.LoopStart, gives us flexibility
            //TODO: add checkboxes to the modal to decide if we want the enum, the generic class with all strings in, the individual sfx classes, or any combination
        }

        private static void GenerateEndOfFile(StringBuilder sb)
        {
            sb.AppendLine("}");
        }

        private static string ToUpperSnakeCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
            {
                return input;
            }

            string result = Regex.Replace(input, @"(?<=[a-z0-9])([A-Z])", "_$1");
            result = Regex.Replace(result, @"(?<=[A-Za-z])([0-9])", "_$1");
            result = Regex.Replace(result, @"(?<=[0-9])([A-Za-z])", "_$1");
            result = Regex.Replace(result, @"_+",                   "_");

            return result.ToUpperInvariant();
        }
    }
}